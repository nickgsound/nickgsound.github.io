<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8">
<title>Hex Grid Background</title>
<style>
  html, body {
    margin: 0;
    padding: 0;
    height: 100%;
    background: black;
    overflow: hidden;
  }
  canvas {
    display: block;
  }
</style>
</head>
<body>

<canvas id="canvas"></canvas>

<script>
const canvasEl = document.getElementById('canvas');
const ctx = canvasEl.getContext('2d');

let dpr = Math.max(1, window.devicePixelRatio || 1);
let width = 0, height = 0;

const params = {
  baseAmp: 2.2,
  hoverAmp: 11,
  mouseRadius: 200,
  speed: 0.0018,
  freq: 0.005,
  fadeDist: 260,
  strokeWidth: 1.1
};

let mouse = { x: Infinity, y: Infinity, inside: false };
const grid = { centers: [], r: 0, stepX: 0, stepY: 0 };

function resize() {
  const w = window.innerWidth;
  const h = window.innerHeight;
  dpr = Math.max(1, window.devicePixelRatio || 1);

  canvasEl.width  = Math.floor(w * dpr);
  canvasEl.height = Math.floor(h * dpr);
  canvasEl.style.width  = w + 'px';
  canvasEl.style.height = h + 'px';

  width = canvasEl.width;
  height = canvasEl.height;
  setupGrid();
}

function setupGrid() {
  const wCss = width / dpr;
  const targetCols = Math.round(wCss / 70);
  const r = Math.max(12, Math.min(40, (wCss / Math.max(8, targetCols)) / 1.5));
  grid.r = r * dpr;
  grid.stepX = 1.5 * grid.r;
  grid.stepY = Math.sqrt(3) * grid.r;

  const pad = grid.r * 1.2;
  const cols = Math.ceil((width + pad * 2) / grid.stepX) + 1;
  const rows = Math.ceil((height + pad * 2) / grid.stepY) + 1;

  grid.centers.length = 0;
  for (let cx = 0; cx < cols; cx++) {
    const x = cx * grid.stepX - pad;
    const yOffset = (cx % 2) ? grid.stepY / 2 : 0;
    for (let cy = 0; cy < rows; cy++) {
      const y = cy * grid.stepY - pad + yOffset;
      grid.centers.push({
        x, y,
        rotation: Math.random() * Math.PI * 2,
        noise: (Math.random() - 0.5) * 2,
        rotPhase: Math.random() * Math.PI * 2
      });
    }
  }

  ctx.lineWidth = params.strokeWidth * dpr;
  ctx.lineJoin = 'round';
  ctx.lineCap = 'round';
}

function hexVertices(cx, cy, r, tShift = 0, amp = 0, rotation = 0) {
  const verts = [];
  for (let i = 0; i < 6; i++) {
    const ang = i * Math.PI / 3 + rotation;
    const radial = amp * Math.sin(tShift + ang * 2);
    const rr = r + radial;
    verts.push({ x: cx + rr * Math.cos(ang), y: cy + rr * Math.sin(ang) });
  }
  return verts;
}

function lerp(a, b, t) { return a + (b - a) * t; }

function drawFrame(ts) {
  const t = ts;
  ctx.setTransform(1, 0, 0, 1, 0, 0);
  ctx.clearRect(0, 0, width, height);

  const pxMouse = { x: mouse.x * dpr, y: mouse.y * dpr };

  for (let c of grid.centers) {
    const phase = t * params.speed + (c.x + c.y) * params.freq * 0.5 + c.rotPhase;
    const baseAmp = params.baseAmp * dpr;

    let extra = 0;
    if (mouse.inside) {
      const dx = pxMouse.x - c.x;
      const dy = pxMouse.y - c.y;
      const dist = Math.hypot(dx, dy);
      if (dist < params.mouseRadius * dpr) {
        const w = 1 - dist / (params.mouseRadius * dpr);
        extra = (params.hoverAmp * dpr) * (w * w);
      }
    }

    const amp = baseAmp + extra;

    const cx = c.x + Math.cos(phase + c.noise) * amp;
    const cy = c.y + Math.sin(phase * 1.1 + c.noise) * amp;
    const verts = hexVertices(cx, cy, grid.r, phase + c.noise, amp * 0.12, c.rotation);

    let alpha = 0.18;
    let glow = 0;
    if (mouse.inside) {
      const dx = pxMouse.x - cx;
      const dy = pxMouse.y - cy;
      const dist = Math.hypot(dx, dy);
      const k = 1 - Math.min(1, dist / (params.fadeDist * dpr));
      alpha = lerp(alpha, 0.5, k);
      glow = 4 * k;
    }

    ctx.beginPath();
    ctx.moveTo(verts[0].x, verts[0].y);
    for (let j = 1; j < 6; j++) ctx.lineTo(verts[j].x, verts[j].y);
    ctx.closePath();

    const grad = ctx.createLinearGradient(verts[0].x, verts[0].y, verts[3].x, verts[3].y);
    grad.addColorStop(0, `rgba(255,255,255,${alpha * 0.3})`);
    grad.addColorStop(0.5, `rgba(255,255,255,${alpha})`);
    grad.addColorStop(1, `rgba(255,255,255,${alpha * 0.3})`);

    ctx.shadowBlur = glow;
    ctx.shadowColor = 'white';
    ctx.strokeStyle = grad;
    ctx.stroke();
  }

  requestAnimationFrame(drawFrame);
}

window.addEventListener('resize', resize);
window.addEventListener('mousemove', e => {
  mouse.x = e.clientX;
  mouse.y = e.clientY;
  mouse.inside = true;
});
window.addEventListener('mouseleave', () => mouse.inside = false);

resize();
requestAnimationFrame(drawFrame);
</script>

</body>
</html>
